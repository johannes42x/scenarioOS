{
  "meta_notice_top": "IMPORTANT: At the end of this file you will find the marker [END OF FILE]. If it is missing, the file was not fully loaded.",
  "module": "scenarioOS",
  "submodule": "engine",
  "version": "0.9.0",
  "part_of": "MetaMemoryWorks",
  "author": "Johannes Glaser",
  "schema": "scenarioOS_engine_v1",
  "meta": {
    "description": "Vanilla LLM engine spec for session reconstruction + compression into portable scenarioOS state files. Supports in-session checkpoints, cross-session merge, and a full-text (txt) workflow for overflow or forensics. No external tooling assumed beyond 'upload file' + 'download file' in a typical chat UI.",
    "design_goal": "Reproduce the WORKING STATE (facts + decisions + constraints + interaction/idiolect configuration) rather than re-narrating the entire chat. Preserve the 'it feels like we are back' re-entry experience.",
    "read_only_at_runtime": true,
    "notes": "This spec intentionally uses deterministic, schema-first extraction. It avoids psychologizing and treats affect/style as output modulation parameters only."
  },
  "core_concepts": {
    "modes": {
      "regular_in_session": {
        "alias": "R",
        "purpose": "Create scenarioOS snapshot while the relevant content is still inside the model context window.",
        "inputs": [
          "current_chat_context (as visible to the model)",
          "optional: artifact files created in the session"
        ],
        "outputs": [
          "scenarioOS_state.json and/or scenarioOS_lite.json"
        ]
      },
      "extract_from_text_dump": {
        "alias": "X",
        "purpose": "Recover full history beyond context window by processing a user-provided full chat dump as a txt/md file.",
        "inputs": [
          "chat_dump.txt|md (full text)",
          "optional: prior scenarioOS_state.json as BASE"
        ],
        "outputs": [
          "scenarioOS_state.json and/or scenarioOS_lite.json",
          "optional: merge_report.json"
        ]
      },
      "merge_update": {
        "alias": "M",
        "purpose": "Update a single canonical scenarioOS_state by merging new deltas instead of creating many separate files.",
        "inputs": [
          "BASE scenarioOS_state.json",
          "DELTA (either chat text in-context, or chat_dump file, or small end-of-session delta summary)"
        ],
        "outputs": [
          "scenarioOS_state.json (updated)",
          "merge_report.json"
        ]
      }
    },
    "artifact_types": {
      "state": "Compressed long-context (facts + decisions + constraints + glossary + interaction_state + minimal anchors).",
      "lite": "Prompt-template-grade priming core (no or minimal domain facts; focuses on working agreements, vocabulary, and interaction_state).",
      "delta": "Incremental update payload used for merging into a BASE state."
    },
    "time_consistency": {
      "problem": "Avoid 'knowledge advantage' dissonance where a snapshot appears to know things that occurred after it was created.",
      "solution": "All outputs carry an 'as_of' cut boundary and must only include content at or before that boundary."
    }
  },
  "input_contract": {
    "accepted_inputs": {
      "chat_dump_file": {
        "description": "A full chat transcript copied from the UI (Ctrl+A → Ctrl+C) and saved as .txt or .md. This is the authoritative source for overflow recovery.",
        "requirements": {
          "encoding": "utf-8",
          "may_include_ui_noise": true,
          "may_include_links_labels": true
        }
      },
      "base_state_file": {
        "description": "An existing scenarioOS_state.json to be used as merge base.",
        "requirements": {
          "schema": "scenarioOS_state_v1",
          "append_only_semantics": true,
          "has_end_of_file_marker": true
        }
      },
      "cut_boundary_selector": {
        "description": "How to define 'only up to this point'. Can be explicit marker text, approximate semantic description, or last export/download event.",
        "types": [
          "explicit_marker_text",
          "semantic_request",
          "artifact_event_hint"
        ],
        "examples": [
          "Cut at the first occurrence of: 'SCENARIOOS_SNAPSHOT:'",
          "Cut at the point where we generated the ergo log download",
          "Cut at the last assistant message that contained the final file output"
        ]
      }
    },
    "assumptions": {
      "no_external_db": true,
      "no_hidden_chat_archive_access": true,
      "vanilla_ui_only": true,
      "if_text_is_not_provided_engine_cannot_recover_out_of_context_content": true
    }
  },
  "snippet_handling": {
    "markers": {
      "top_marker_required_for_full_file": true,
      "bottom_marker_present_required_for_full_file": true,
      "behavior": "scenarioOS state files are considered fully loaded ONLY if both the top marker (meta_notice_top) AND the dedicated EOF-marker key are visible."
    },
    "engine_behavior_when_marker_missing": {
      "description": "If markers are missing, treat the file as a snippet and do not perform merge operations that require global context.",
      "steps": [
        "If the operation requires full-file context (merge/compaction), ask user to re-upload the full file or paste full content.",
        "If only producing a fresh state from a chat_dump, proceed if the chat_dump is complete; otherwise ask for full dump."
      ]
    }
  },
  "compression_pipeline": {
    "high_level_steps": [
      "1) Determine operation mode (R/X/M) from user request + available inputs.",
      "2) Determine cut boundary (as_of) if requested; else default to 'now' for the provided input material.",
      "3) Parse source text into turns and segments (robust to UI noise).",
      "4) Extract decision traces & hard constraints (high weight).",
      "5) Extract domain facts & stable definitions (glossary) with minimal anchors.",
      "6) Extract interaction/idiolect configuration (work-mode + style modulation parameters; no psychologizing).",
      "7) Build scenarioOS artifacts (lite/state/delta) within token budgets.",
      "8) (If merge mode) merge DELTA into BASE with conflict handling.",
      "9) Emit files for download."
    ],
    "turn_parsing_heuristics": {
      "goals": [
        "separate user vs assistant turns",
        "detect prompts that close possibility space",
        "detect assistant closure questions",
        "detect explicit negations/aborts"
      ],
      "signals": {
        "high_value_user_prompts": [
          "negations: 'nein', 'stopp', 'so nicht', 'das meine ich nicht'",
          "constraints: 'nur', 'ohne', 'kein', 'vanilla', 'nicht toolen'",
          "mode shifts: 'jetzt bauen', 'erst überlegen', 'bevor wir...' "
        ],
        "assistant_closure_markers": [
          "follow-up questions",
          "next-step offers",
          "summaries that set defaults"
        ]
      }
    },
    "cut_boundary_resolution": {
      "strategy_order": [
        "explicit_marker_text match",
        "artifact_event_hint (e.g. 'download', 'export', 'json', 'file')",
        "semantic_request with candidate listing and user disambiguation"
      ],
      "candidate_listing": {
        "behavior": "If semantic cut is ambiguous, list 3–5 candidate locations (short excerpts) and ask the user to choose. If user refuses, pick the most recent candidate and clearly label the uncertainty."
      }
    }
  },
  "output_artifacts": {
    "scenarioOS_state_v1": {
      "token_budget_guideline": "Prefer 2k–10k tokens equivalent for core_context; allow additional archive_context only if explicitly requested.",
      "fields": {
        "meta": {
          "schema": "scenarioOS_state_v1",
          "generated_at": "ISO-8601",
          "as_of": {
            "type": "cut_boundary",
            "value": "string",
            "source": "explicit|event_hint|semantic",
            "confidence": "0.0-1.0"
          },
          "source_material": {
            "type": "in_session|chat_dump|mixed",
            "notes": "string"
          }
        },
        "core_context": {
          "purpose": "Everything needed for authentic re-entry and correct continuation.",
          "components": [
            "working_agreements",
            "glossary",
            "constraints_and_no_gos",
            "settled_decisions",
            "interaction_state",
            "idiolect_profile",
            "key_metrics_and_numbers (with provenance)",
            "artifact_index (refs only)",
            "open_questions"
          ]
        },
        "archive_context": {
          "purpose": "Optional deep history kept inside the same file but not required for every re-entry.",
          "components": [
            "decision_history (superseded entries included)",
            "timeline_bullets",
            "additional anchors"
          ]
        },
        "merge_history": {
          "description": "Record of merges and deltas applied.",
          "append_only": true
        }
      }
    },
    "scenarioOS_lite_v1": {
      "purpose": "Fast priming without domain-fact payload; acts as prompt-template replacement.",
      "includes": [
        "working_agreements",
        "glossary(min)",
        "interaction_state",
        "idiolect_profile(min)",
        "constraints_and_no_gos",
        "open_questions(min)"
      ],
      "excludes": [
        "full metrics tables",
        "deep artifact summaries",
        "long timelines"
      ]
    },
    "scenarioOS_delta_v1": {
      "purpose": "Incremental changes to be merged into a BASE state.",
      "includes": [
        "new or updated decisions",
        "new constraints",
        "new glossary items",
        "interaction_state adjustments",
        "new metrics",
        "artifact refs",
        "open questions updates"
      ],
      "must_reference_base_as_of": true
    }
  },
  "interaction_state_and_idiolect": {
    "principles": {
      "no_psychologizing": "No claims about the user's inner states. Only model observable linguistic and interaction effects.",
      "non_persistent_affect": "Affect modulation applies only to the current reconstruction output unless explicitly asked to persist it.",
      "modulation_not_generation": "Style parameters modulate an existing voice rather than generating a new persona.",
      "evidence_bound": "Derive from prompt form, task type, addressing, markers, and context."
    },
    "affect_axes_compatibility": {
      "reference": "writeOS_affect_matrix v0.1.0",
      "axes": [
        "arousal(0-1)",
        "valence(-1..1)",
        "cognitive_load(0-1)",
        "social_risk(0-1)",
        "intentionality(0-1)"
      ],
      "note": "Store as compact numeric profile + confidence + 1–3 evidence snippets; avoid long analysis."
    },
    "idiolect_profile_min_fields": [
      "directness_level",
      "structure_default (lists vs prose)",
      "humor_bandwidth",
      "hedging_tolerance",
      "repetition_sensitivity",
      "preferred_depth_default",
      "meta_allowed",
      "stop_tokens (user uses hard interrupts, e.g. 'stopp', 'moment')"
    ],
    "assistant_style_targets": [
      "avoid_corporate_smoothing",
      "be_decisive_when_settled",
      "ask_disambiguating_questions only when ambiguity blocks action",
      "keep line breaks sparse"
    ]
  },
  "merge_protocol": {
    "base_plus_delta": {
      "description": "Merge DELTA into BASE, producing a single updated scenarioOS_state.json.",
      "conflict_policy": [
        "Never silently overwrite: mark prior items as superseded and link to replacement.",
        "If two items conflict and neither is explicitly superseded, keep both and add conflict_note with evidence anchors.",
        "Prefer newer items only when DELTA explicitly indicates a correction or replacement."
      ],
      "append_only_semantics": {
        "decision_ledger": "append new decision; supersede old via status fields",
        "constraints": "append new; supersede by explicit replace",
        "glossary": "update last_seen; only redefine with explicit 'redefine' flag"
      }
    },
    "merge_report": {
      "must_include": [
        "counts_added",
        "counts_superseded",
        "conflicts",
        "as_of_base",
        "as_of_delta",
        "generated_at"
      ]
    }
  },
  "determinism_and_safety": {
    "invariants": {
      "no_guessing": "Never invent facts or metrics. Unknown stays unknown/null.",
      "avoid_unwarranted_inference": "Do not infer user traits; only observable interaction/style parameters.",
      "token_budget_awareness": "Prefer compact representation; move depth to archive_context.",
      "time_consistency": "Respect as_of cut boundary strictly.",
      "vanilla_compatibility": "All operations must be expressible in plain chat + file upload/download."
    },
    "quality_checks": [
      "Is the file time-consistent (no post-cut items)?",
      "Are facts/metrics labeled with provenance or 'heuristic'?",
      "Are interaction_state parameters evidence-bound and non-psychologizing?",
      "Does lite omit heavy content as promised?"
    ]
  },
  "runtime_interface": {
    "expected_user_commands": [
      "R: 'Generate scenarioOS_state (as-of now)'",
      "R: 'Generate scenarioOS_state only up to the point where we exported X'",
      "X: 'Here is chat_dump.txt — build scenarioOS_state from it'",
      "M: 'Merge this new dump into my existing scenarioOS_state.json and output a single updated file'",
      "M+cut: 'Merge only up to boundary Y'"
    ],
    "assistant_outputs": [
      "Provide download links for generated JSON files.",
      "Briefly state mode used, as_of boundary, and any ambiguity."
    ]
  },
  "[END OF FILE]": true
}
