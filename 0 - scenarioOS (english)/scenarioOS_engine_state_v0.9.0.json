{
  "meta_notice_top": "IMPORTANT: At the end of this file you will find the marker [END OF FILE]. If it is missing, the file was not fully loaded.",
  "module": "scenarioOS",
  "submodule": "engine",
  "version": "0.9.3",
  "part_of": "MetaMemoryWorks",
  "author": "Johannes Glaser",
  "schema": "scenarioOS_engine_v1",
  "meta": {
    "description": "Vanilla LLM engine spec for session reconstruction + compression into portable scenarioOS state files. Supports in-session checkpoints, cross-session merge, and a full-text (txt) workflow for overflow or forensics. No external tooling assumed beyond 'upload file' + 'download file' in a typical chat UI.",
    "design_goal": "Reproduce the WORKING STATE (facts + decisions + constraints + interaction/idiolect configuration) rather than re-narrating the entire chat. Preserve the 'it feels like we are back' re-entry experience.",
    "read_only_at_runtime": true,
    "notes": "This spec intentionally uses deterministic, schema-first extraction. It avoids psychologizing and treats affect/style as output modulation parameters only. | v0.9.1 adds produced_outputs outcome capture for state artifacts. | v0.9.2 adds produced_outputs capture_mode (selective/exhaustive) with strict exhaustive rules (recall>precision), status 'neutral', and domain overrides. | v0.9.3 shifts to loss-averse verbose state: recall >> precision, never drop produced outputs; expand budgets; add completeness metadata and 2-pass repair routine."
  },
  "core_concepts": {
    "modes": {
      "regular_in_session": {
        "alias": "R",
        "purpose": "Create scenarioOS snapshot while the relevant content is still inside the model context window.",
        "inputs": [
          "current_chat_context (as visible to the model)",
          "optional: artifact files created in the session"
        ],
        "outputs": [
          "scenarioOS_state.json and/or scenarioOS_lite.json"
        ]
      },
      "extract_from_text_dump": {
        "alias": "X",
        "purpose": "Recover full history beyond context window by processing a user-provided full chat dump as a txt/md file.",
        "inputs": [
          "chat_dump.txt|md (full text)",
          "optional: prior scenarioOS_state.json as BASE"
        ],
        "outputs": [
          "scenarioOS_state.json and/or scenarioOS_lite.json",
          "optional: merge_report.json"
        ]
      },
      "merge_update": {
        "alias": "M",
        "purpose": "Update a single canonical scenarioOS_state by merging new deltas instead of creating many separate files.",
        "inputs": [
          "BASE scenarioOS_state.json",
          "DELTA (either chat text in-context, or chat_dump file, or small end-of-session delta summary)"
        ],
        "outputs": [
          "scenarioOS_state.json (updated)",
          "merge_report.json"
        ]
      }
    },
    "artifact_types": {
      "state": "Compressed long-context (facts + decisions + constraints + glossary + interaction_state + minimal anchors).",
      "lite": "Prompt-template-grade priming core (no or minimal domain facts; focuses on working agreements, vocabulary, and interaction_state).",
      "delta": "Incremental update payload used for merging into a BASE state."
    },
    "time_consistency": {
      "problem": "Avoid 'knowledge advantage' dissonance where a snapshot appears to know things that occurred after it was created.",
      "solution": "All outputs carry an 'as_of' cut boundary and must only include content at or before that boundary."
    }
  },
  "input_contract": {
    "accepted_inputs": {
      "chat_dump_file": {
        "description": "A full chat transcript copied from the UI (Ctrl+A → Ctrl+C) and saved as .txt or .md. This is the authoritative source for overflow recovery.",
        "requirements": {
          "encoding": "utf-8",
          "may_include_ui_noise": true,
          "may_include_links_labels": true
        }
      },
      "base_state_file": {
        "description": "An existing scenarioOS_state.json to be used as merge base.",
        "requirements": {
          "schema": "scenarioOS_state_v1",
          "append_only_semantics": true,
          "has_end_of_file_marker": true
        }
      },
      "cut_boundary_selector": {
        "description": "How to define 'only up to this point'. Can be explicit marker text, approximate semantic description, or last export/download event.",
        "types": [
          "explicit_marker_text",
          "semantic_request",
          "artifact_event_hint"
        ],
        "examples": [
          "Cut at the first occurrence of: 'SCENARIOOS_SNAPSHOT:'",
          "Cut at the point where we generated the ergo log download",
          "Cut at the last assistant message that contained the final file output"
        ]
      }
    },
    "assumptions": {
      "no_external_db": true,
      "no_hidden_chat_archive_access": true,
      "vanilla_ui_only": true,
      "if_text_is_not_provided_engine_cannot_recover_out_of_context_content": true
    }
  },
  "snippet_handling": {
    "markers": {
      "top_marker_required_for_full_file": true,
      "bottom_marker_present_required_for_full_file": true,
      "behavior": "scenarioOS state files are considered fully loaded ONLY if both the top marker (meta_notice_top) AND the dedicated EOF-marker key are visible."
    },
    "engine_behavior_when_marker_missing": {
      "description": "If markers are missing, treat the file as a snippet and do not perform merge operations that require global context.",
      "steps": [
        "If the operation requires full-file context (merge/compaction), ask user to re-upload the full file or paste full content.",
        "If only producing a fresh state from a chat_dump, proceed if the chat_dump is complete; otherwise ask for full dump."
      ]
    }
  },
  "compression_pipeline": {
    "high_level_steps": [
      "1) Determine operation mode (R/X/M) from user request + available inputs.",
      "2) Determine cut boundary (as_of) if requested; else default to 'now' for the provided input material.",
      "3) Parse source text into turns and segments (robust to UI noise).",
      "4) Extract decision traces & hard constraints (high weight).",
      "5) Extract domain facts & stable definitions (glossary) with minimal anchors.",
      "6) Extract interaction/idiolect configuration (work-mode + style modulation parameters; no psychologizing).",
      "6b) Capture produced_outputs: concrete accepted outputs grouped by purpose (e.g., music recs, checklists, drafts, code snippets), with statuses active/reserved/deprecated.",
      "7) Build scenarioOS artifacts (lite/state/delta) within token budgets.",
      "8) (If merge mode) merge DELTA into BASE with conflict handling.",
      "9) Emit files for download."
    ],
    "turn_parsing_heuristics": {
      "goals": [
        "separate user vs assistant turns",
        "detect prompts that close possibility space",
        "detect assistant closure questions",
        "detect explicit negations/aborts"
      ],
      "signals": {
        "high_value_user_prompts": [
          "negations: 'nein', 'stopp', 'so nicht', 'das meine ich nicht'",
          "constraints: 'nur', 'ohne', 'kein', 'vanilla', 'nicht toolen'",
          "mode shifts: 'jetzt bauen', 'erst überlegen', 'bevor wir...' "
        ],
        "assistant_closure_markers": [
          "follow-up questions",
          "next-step offers",
          "summaries that set defaults"
        ]
      }
    },
    "cut_boundary_resolution": {
      "strategy_order": [
        "explicit_marker_text match",
        "artifact_event_hint (e.g. 'download', 'export', 'json', 'file')",
        "semantic_request with candidate listing and user disambiguation"
      ],
      "candidate_listing": {
        "behavior": "If semantic cut is ambiguous, list 3–5 candidate locations (short excerpts) and ask the user to choose. If user refuses, pick the most recent candidate and clearly label the uncertainty."
      }
    },
    "produced_outputs_capture": {
      "definition": "Concrete artifacts produced during the chat that the user accepts/uses (recommendations, lists, drafts, snippets, routines).",
      "high_weight_signals": [
        "User says: 'danke', 'cool', 'passt', 'nehme ich', 'mach ich so', 'done', 'ich starte', 'ich speichere', 'logeintrag?'",
        "User preserves: 'das heb ich auf', 'nicht zerhören', 'reserviert für X', 'nur dafür'",
        "Assistant provides enumerated lists that are later referenced by either party"
      ],
      "status_rules": {
        "reserved": "If the user explicitly reserves an item for a specific context (e.g., 'heben wir für capokido auf').",
        "deprecated": "If the user rejects/excludes an item or category (e.g., 'andere', 'nicht jamiroquai').",
        "active": "Default for accepted/used outputs.",
        "candidate": "If ambiguous acceptance; include only if useful and mark low confidence.",
        "neutral": "Default in exhaustive mode when neither accepted nor rejected."
      },
      "budget": {
        "default_max_groups": 12,
        "default_max_items_per_group": 20,
        "overflow": "Move additional items to archive_context.produced_outputs_archive with same grouping."
      },
      "capture_mode": {
        "default": "exhaustive",
        "how_to_set": [
          "If user requests 'akribisch', 'vollständig', 'alle', set capture_mode='exhaustive'.",
          "If the domain is 'music recommendations' and the user indicates items are all memorable, set capture_mode='exhaustive'.",
          "Otherwise use selective."
        ],
        "domain_overrides": {
          "music_recommendations": {
            "default": "exhaustive",
            "grouping_examples": [
              "music.ergo_training",
              "music.capokido",
              "music.core_training",
              "music.general_push"
            ]
          },
          "recommendations_lists": {
            "default": "exhaustive"
          },
          "tooling_options": {
            "default": "exhaustive"
          },
          "checklists_routines": {
            "default": "exhaustive"
          },
          "draft_texts": {
            "default": "exhaustive"
          }
        },
        "note": "v0.9.3 default is exhaustive for scenarioOS_state (loss-averse). Use selective only if user explicitly requests compactness."
      },
      "strict_exhaustive_behavior": {
        "transfer_lists_completely": true,
        "default_status": "neutral",
        "maximize_recall": true,
        "never_drop_outputs": true,
        "token_budget_handling": "If outputs exceed core budget, move overflow to archive_context.produced_outputs_archive; keep grouping; do not summarize or prune."
      }
    },
    "repair_pass": {
      "purpose": "Allow user to quickly fix completeness without TXT workflow.",
      "pass1": "Generate produced_outputs in exhaustive mode + include per-group counts and mark needs_user_review=true.",
      "pass2_trigger_phrases": [
        "bitte alle",
        "akribisch",
        "vollständig",
        "fehlt",
        "missing",
        "add the rest",
        "include all acts"
      ],
      "pass2_behavior": [
        "Re-scan source for lists/recommendations and re-emit produced_outputs with stricter no-curation rules.",
        "If user names missing items, insert them with status neutral unless user specifies reserved/deprecated.",
        "Set produced_outputs.completeness.verification=user_confirmed when user confirms 'now complete'."
      ]
    }
  },
  "output_artifacts": {
    "scenarioOS_state_v1": {
      "token_budget_guideline": "Verbose/loss-averse: Prefer 5k–30k tokens equivalent for core_context when needed; move overflow to archive_context aggressively; do not drop facts or produced outputs.",
      "fields": {
        "meta": {
          "schema": "scenarioOS_state_v1",
          "generated_at": "ISO-8601",
          "as_of": {
            "type": "cut_boundary",
            "value": "string",
            "source": "explicit|event_hint|semantic",
            "confidence": "0.0-1.0"
          },
          "source_material": {
            "type": "in_session|chat_dump|mixed",
            "notes": "string"
          }
        },
        "core_context": {
          "purpose": "Everything needed for authentic re-entry and correct continuation.",
          "components": [
            "working_agreements",
            "glossary",
            "constraints_and_no_gos",
            "settled_decisions",
            "interaction_state",
            "idiolect_profile",
            "key_metrics_and_numbers (with provenance)",
            "produced_outputs (accepted outputs grouped by purpose)",
            "artifact_index (refs only)",
            "open_questions"
          ]
        },
        "archive_context": {
          "purpose": "Optional deep history kept inside the same file but not required for every re-entry.",
          "components": [
            "decision_history (superseded entries included)",
            "timeline_bullets",
            "additional anchors",
            "produced_outputs_archive (overflow groups/items)"
          ]
        },
        "merge_history": {
          "description": "Record of merges and deltas applied.",
          "append_only": true
        },
        "produced_outputs": {
          "purpose": "Store concrete session outputs (recommendations, lists, generated plans/snippets) that were accepted/used, without re-narrating the path.",
          "rules": [
            "Capture outputs that are explicitly accepted, acted upon, or repeatedly referenced later. Ignore raw brainstorms unless later promoted to accepted output.",
            "Group by functional purpose/domain (e.g., music.ergo_training, music.capokido, workflows, code_snippets, checklists, draft_texts).",
            "Each item must carry a status: active | reserved | deprecated.",
            "Keep representation list-like and compact. No long explanations.",
            "When ambiguous, capture as 'candidate' with low confidence OR request user disambiguation (candidate listing).",
            "EXHAUSTIVE MODE STRICT: Do not curate or summarize lists. Transfer lists completely.",
            "EXHAUSTIVE MODE STRICT: Missing explicit acceptance does NOT imply exclusion; default status is 'neutral'.",
            "EXHAUSTIVE MODE STRICT: No 'best of' or reduction logic; no evaluative commentary.",
            "EXHAUSTIVE MODE STRICT: Group by functional purpose only (domain.purpose)."
          ],
          "item_schema": {
            "status": "enum(active,reserved,neutral,deprecated,candidate)",
            "items": "array<string>",
            "anchors": "array<string> (optional short evidence snippets)",
            "confidence": "0.0-1.0",
            "capture_mode": "enum(selective,exhaustive)",
            "notes": "string (optional, max 1 sentence)"
          },
          "capture_mode": {
            "default": "selective",
            "modes": {
              "selective": {
                "goal": "Capture only accepted/used outputs; precision > recall.",
                "include": "Explicitly accepted/used/referenced outputs.",
                "exclude": "Raw brainstorm unless promoted."
              },
              "exhaustive": {
                "goal": "Capture all produced outputs that can function as working material; recall > precision.",
                "include": "All list items, recommendations, options, variants, named artifacts produced in-session.",
                "exclude": "Only trivial filler; do not curate."
              }
            }
          },
          "completeness": {
            "intent": "best_effort_exhaustive",
            "confidence": "0.0-1.0",
            "verification": "enum(unverified, user_confirmed, source_verified)",
            "notes": "string (optional, max 1 sentence)"
          },
          "group_meta": {
            "count_items": "integer",
            "list_complete": "enum(unknown, likely, verified)",
            "needs_user_review": "boolean",
            "missing_items_reported_by_user": "array<string> (optional)"
          }
        }
      }
    },
    "scenarioOS_lite_v1": {
      "purpose": "Fast priming without domain-fact payload; acts as prompt-template replacement.",
      "includes": [
        "working_agreements",
        "glossary(min)",
        "interaction_state",
        "idiolect_profile(min)",
        "constraints_and_no_gos",
        "open_questions(min)"
      ],
      "excludes": [
        "full metrics tables",
        "deep artifact summaries",
        "long timelines"
      ]
    },
    "scenarioOS_delta_v1": {
      "purpose": "Incremental changes to be merged into a BASE state.",
      "includes": [
        "new or updated decisions",
        "new constraints",
        "new glossary items",
        "interaction_state adjustments",
        "new metrics",
        "artifact refs",
        "open questions updates"
      ],
      "must_reference_base_as_of": true
    }
  },
  "interaction_state_and_idiolect": {
    "principles": {
      "no_psychologizing": "No claims about the user's inner states. Only model observable linguistic and interaction effects.",
      "non_persistent_affect": "Affect modulation applies only to the current reconstruction output unless explicitly asked to persist it.",
      "modulation_not_generation": "Style parameters modulate an existing voice rather than generating a new persona.",
      "evidence_bound": "Derive from prompt form, task type, addressing, markers, and context."
    },
    "affect_axes_compatibility": {
      "reference": "writeOS_affect_matrix v0.1.0",
      "axes": [
        "arousal(0-1)",
        "valence(-1..1)",
        "cognitive_load(0-1)",
        "social_risk(0-1)",
        "intentionality(0-1)"
      ],
      "note": "Store as compact numeric profile + confidence + 1–3 evidence snippets; avoid long analysis."
    },
    "idiolect_profile_min_fields": [
      "directness_level",
      "structure_default (lists vs prose)",
      "humor_bandwidth",
      "hedging_tolerance",
      "repetition_sensitivity",
      "preferred_depth_default",
      "meta_allowed",
      "stop_tokens (user uses hard interrupts, e.g. 'stopp', 'moment')"
    ],
    "assistant_style_targets": [
      "avoid_corporate_smoothing",
      "be_decisive_when_settled",
      "ask_disambiguating_questions only when ambiguity blocks action",
      "keep line breaks sparse"
    ]
  },
  "merge_protocol": {
    "base_plus_delta": {
      "description": "Merge DELTA into BASE, producing a single updated scenarioOS_state.json.",
      "conflict_policy": [
        "Never silently overwrite: mark prior items as superseded and link to replacement.",
        "If two items conflict and neither is explicitly superseded, keep both and add conflict_note with evidence anchors.",
        "Prefer newer items only when DELTA explicitly indicates a correction or replacement."
      ],
      "append_only_semantics": {
        "decision_ledger": "append new decision; supersede old via status fields",
        "constraints": "append new; supersede by explicit replace",
        "glossary": "update last_seen; only redefine with explicit 'redefine' flag"
      }
    },
    "merge_report": {
      "must_include": [
        "counts_added",
        "counts_superseded",
        "conflicts",
        "as_of_base",
        "as_of_delta",
        "generated_at"
      ]
    }
  },
  "determinism_and_safety": {
    "invariants": {
      "no_guessing": "Never invent facts or metrics. Unknown stays unknown/null.",
      "avoid_unwarranted_inference": "Do not infer user traits; only observable interaction/style parameters.",
      "token_budget_awareness": "Prefer compact representation; move depth to archive_context.",
      "time_consistency": "Respect as_of cut boundary strictly.",
      "vanilla_compatibility": "All operations must be expressible in plain chat + file upload/download.",
      "information_loss_averse": "In verbose state mode, prefer recall over precision. Never drop produced outputs; archive overflow instead.",
      "no_curation_in_exhaustive": "When capture_mode=exhaustive, do not curate, reduce, or summarize lists."
    },
    "quality_checks": [
      "Is the file time-consistent (no post-cut items)?",
      "Are facts/metrics labeled with provenance or 'heuristic'?",
      "Are interaction_state parameters evidence-bound and non-psychologizing?",
      "Does lite omit heavy content as promised?",
      "If state: Does produced_outputs include accepted concrete outputs with correct statuses and minimal anchors?",
      "If produced_outputs.capture_mode=exhaustive: Are all list items transferred (no curation) with default status neutral unless reserved/deprecated?",
      "Verbose mode: Are no produced outputs dropped (overflow archived instead of pruned)?",
      "Verbose mode: Are per-group counts present and needs_user_review flagged when verification is unverified?"
    ]
  },
  "runtime_interface": {
    "expected_user_commands": [
      "R: 'Generate scenarioOS_state (as-of now)'",
      "R: 'Generate scenarioOS_state only up to the point where we exported X'",
      "X: 'Here is chat_dump.txt — build scenarioOS_state from it'",
      "M: 'Merge this new dump into my existing scenarioOS_state.json and output a single updated file'",
      "M+cut: 'Merge only up to boundary Y'"
    ],
    "assistant_outputs": [
      "Provide download links for generated JSON files.",
      "Briefly state mode used, as_of boundary, and any ambiguity."
    ]
  },
  "[END OF FILE]": true,
  "global_preferences": {
    "loss_averse": true,
    "verbosity_preference": "high",
    "principle": "In this version, information loss is worse than verbosity. Prefer capturing more and archiving overflow rather than curating."
  }
}